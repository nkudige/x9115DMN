#Paper 2 - Summary

#Reference
Gary Wassermann, Dachuan Yu, Ajay Chander, Dinakar Dhurjati, Hiroshi Inamura and Zhendong Su (2008).  
"Dynamic Test Input Generation for Web Applications"  
*ISSTA '08 Proceedings of the 2008 international symposium on Software testing and analysis*, 249-260.  
[Link](http://dl.acm.org/citation.cfm?id=1390661)  

##Keywords:
* ii1. **Automatic test generation**: This is the process of automatically generating the test input values for the functions in a program. To determine the input values for a method, techniques like constraint generation and constraint resolution are used. Care is taken to generate different test inputs to cover all possible paths of code.
* ii2. **Concolic Testing**: Concolic testing is a hybrid software verification technique that performs symbolic execution, a technique that treats program variables as symbolic variables, along a concrete execution path. With the aim of maximizing code coverage, Symbolic execution is used in conjunction with Automated theorem prover or constraint solver based on constraint programming to generate new concrete inputs.
* ii3. **Constraint generation**: The process of iteratively executing the program, recording symbolic constraints and using the constraints to generate new inputs that will trigger the execution along a different path during the following iterations.
* ii4. **Selective constraint generation**: This is the process of selectively gathering constraint from a set of functions. This helps reduce the size of the constraints by a several order of magnitudes and thus helps scaling to larger programs. This is done by narrowing the focus of constraint generation to constraints that are relevant to possible failures. Points of possible failure are identified and all functions in which these points occur are added to a set of functions to be analyzed. These functions are then executede and constraints are gathered only from the functions in this set.

##Artifacts:
* iii1. **Motivation**: Web applications offer more features, handle more sensitive data and interact with data generated by different sources. Users increasingly rely on them for daily activities. Thus the need for correctness of web applications is critical. To achieve correctness of web applications, testing plays an important role. Manual testing however requires extensive human effort and is slow. This motivates the need to automate testing of web applications. 
* iii2. **Related Work**:
 - **Test input generation**: Test input generation techniques that make use of program executions to gather symbolic constraints and concrete values from program executions and use these concrete values to help resolve the constraints to generate the next input. This approach which works on numbers, pointer based data structures and thread interleavings is appropriate for languages like C and JAVA. But scripting languages used in web applications encourage a style in which strings and associative arrays play a central role.
 - **Web application testing**: Previous work of testing web application has focused on static web pages and control flow between them. Other works are focused on server side code. There has also been work done on testing that focused on page-coverage metric. Using UML models to analyze static pages, exploring web pages by following sequences of links in web applications are few other approaches used for web application testing.
 - **Static Analysis of web applications**: These tests can only check if raw user inputs flow into sensitive sinks.To implement dynamic dispatch or for dynamically loaded modules or for database handling code, PHP uses dynamic features extensively.In such cases, the values of interpreted strings depend only indirectly on user input, and for any given run, the predicates on user inputs are not dynamically constructed.

* iii4. **Limitations**:
 - The constraint resolution algorithm generates constraints only based on one variable instance per value. But for programs with multiple variables, it may miss paths that other resolution algorithms might find.
 - Selective logging is effective only when the points of possible failure are known and relatively localized. Selective logging will be not very effective if the programs are potentially more ubiquitous in the program code, similar to arbitrary run time exceptions. Logging the whole execution would solve the problem, but would be expensive.

* iii5. **Sampling procedures**: For testing the algorithm, three real-world PHP web appications with known SQL injecetions vulnerabilities were selected.  
 - Mantis 1.0.0rc2 has SQL injection vulnerability in its "lost password" page.  
 - Mamboo 4.5.3, has an SQL injection vulnerability in its “submit weblink” page.  

##Areas of Improvement:
* iv1. **Handling other error types apart from SQL injection**: The paper doesnt address how web applications with errors other than SQL injection are tested. The web applications used for testing all contain only SQL injection type of errors and other error types have not been addressed.
* iv2. **Performance testing**: The paper does not address performance testing, where the time required for execution of a function is measured for various inputs. As performance is an important factor for most of the real time web applications, it would be good if the paper addressed this concern.
* iv3. **No statistics on branch coverage**: As part of the evaluation of the algorithm for various web applications, presentation of the statistics about the branch coverage would have been a good evaluation factor for the algorithm.
